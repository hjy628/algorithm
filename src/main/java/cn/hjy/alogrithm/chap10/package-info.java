package cn.hjy.alogrithm.chap10;


/**
 *   很多时候，算法还会与数学有关，如果从数据的角度简化一些问题，那么简化之后的算法的实现效率会更高
 *
 *   大多数一线互联网公司喜欢面试的问题：
 *
 *      1:不使用额外的空间交换两个数
 *              给定两个数A和B，要求交换两个数，但是不能使用额外的空间，也就是在处理的时候不能声明其他变量。
 *                  对两个数进行交换，都是通过一个中间变量来临时保存一个数，然后分别赋值完成交换的，如果不用临时变量，就要用A或B来做临时变量
 *                  A=A+B
 *                  B=A-B;(=A+B-B=A)
 *                  A=A-B;(=A+B-A=B)
 *
 *                  异运算或位运算： A=A^B, B=B^A, A=A^B
 *          延伸的问题：不通过比较，找出两个数中较大的数。 解法：只能通过位运算来处理。
 *
 *          1.a==b 异或则为0
 *           2.a < b 从高位向低位数起，二者第一次出现不同的二进制位时，a在该位处的值一定为0，b在该位处的值一定为1,反之亦然。
 *
 *            int compare(uint32_t a, uint32_t b) {
 *            uint32_t diff = a ^ b;    //找diff中为1的那一位，a | 0 不变，a | 1 置1 ，那么>>16之后，为1的那一位还是1，为1之后的所有位都被置1
 *            if (!diff) return 0;
 *
 *            // 001xxxxx -> 00100000
 *            diff |= diff >> 1;        //为1的那一位置1，其他所有位因为异或，置0
 *            diff |= diff >> 2;
 *            diff |= diff >> 4;
 *            diff |= diff >> 8;
 *            diff |= diff >> 16;
 *            diff ^= diff >> 1;
 *            return a & diff ? 1 : -1;  //检验a在该位是0还是1，是0的话说明a小，是1的话说明a大
 *            }

 *
 *        2:拿乒乓球问题
 *              有100个乒乓球，和另一个人轮流拿球，一次最少拿一个，最多拿5个，谁拿到最后1个谁就赢了，问先拿球的话怎么拿一定可以赢
 *                      分析：不管开始怎么拿，先看下如果想拿到最后1个球，最后那次怎么办到的，如果想要拿到最后1个球，则一定要让后面剩下6个球，如果后面剩下6个球，
 *                      则不管对方拿几个球，自己就拿6减去几个球，这样一定能拿到最后1个球。
 *
 *                      解决：往前推，在倒数第2轮的6个球时也是这样，对方拿几个球，也拿6减去几个球，总共100个球，一直这样拿，那么往前推会有96个球，总共16轮这样的操作。
 *                      最后，前面剩下4个球，所以若先拿，就拿4个球，这样不管对方之后拿几个球，都拿6减去几个球，这样最后一个球就一定是自己拿的。
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */