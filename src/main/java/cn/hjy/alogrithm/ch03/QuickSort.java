package cn.hjy.alogrithm.ch03;

/**
 * Created by hjy on 17-8-21.
 * 快速排序
 *
 *  快速排序的原理非常简单，在待排序的数列中，首先找一个数字作为基准数（只是个专用名词）
 *  为了方便，一般选择地一个数字作为基准数（选择第几个并没有关系）
 *  接下来把这个待排序的数列中小于基准数的元素一定到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边
 *  这是，左右两个分区的元素就相对有序了，接着把两个分区的元素分别按照上面两中方法继续对每个分区找出基准数，然后一懂，直到各个分区只有一个数时为止
 *
 *  快速排序的优化:
 *  1:三者取中法 由于每次选择基准值都选择第一个，会产生一个问题，就是可能会造成每次都需要移动，这样会使算法的性能很差，趋向于O(n^2) 所以要找出中间位置的值，
 *  我们希望基准值能够更接近中间位置的值，所以这里可以每次使用待排序的数列部分的头、尾、中间数，在三个数中取中间大小的那个数作为基准值，然后进行快速排序，这样能够
 *  对一些情况进行优化
 *  2:根据规模大小改变算法    由于在数据量较小的情况下，性能并没有其他算法号，所以我们可以在待排序的数列分区小于某个值后，采用其他算法进行排序
 *  而不是继续使用快速排序，一般这个值可以为5-25，一些编程语言中使用10或者15作为这个量
 *  3其他分区方案考虑   有时我们选择的基准数在数列中可能存在多个，这时我们可以考虑改变分区的方案，那就是三个分区，除了小于基准数的区间，大于基准数的区间
 *  还可以交换出一个等于基准数的区间，这样我们在之后每次进行递归时，就只递归小于和大于两个部分的区间，对于等于基准数的区间就不再考虑了
 *  4并行处理   由于快速排序对于数组中每一小段范围进行排序，对其他段并没有影响，所以可以采用现在计算机的多线程并行处理来提高效率，这并不算是对算法的优化、
 *  只能说是一种对于数量稍微多一些的数据使用快速排序时的一个高效解决方案
 *
 */
public class QuickSort {

    private int[] array;

    public QuickSort(int[] array) {
        this.array = array;
    }

    public void sort(){
        quickSort(array,0,array.length-1);
    }

    public void print(){
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
    }

    public void quickSort(int[] src,int begin,int end){
        if (begin<end){
            int key = src[begin];
            int i = begin;
            int j = end;

            while (i<j){
                while (i<j&&src[j]>key){
                    j--;
                }
                if (i<j){
                    src[i]=src[j];
                    i++;
                }
                while (i<j&&src[i]<key){
                    i++;
                }
                if (i<j){
                    src[j] = src[i];
                    j--;
                }
            }
            src[i] = key;
            quickSort(src, begin, i-1);
            quickSort(src, i+1, end);
        }
    }



}
